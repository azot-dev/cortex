---
sidebar_position: 4
---

# Services

A service contain methods, it can be simple methods or event hooks

```ts
type State = { count: number };

export class CounterService extends Service<State> {
  state: State = { count: 0 };

  async decrement() {
    if (this.state.count === 0) {
      return;
    }
    this.state.count--;
  }

  useDecrementOnFirstRender() {
    useEffect(() => {
      this.decrement();
    }, []);
  }
}
```

The methods of a service can:

## Access to the state

You can access the local state by reading and writing directly on its properties. Thanks to valtio, the state is automatically reactive.

In this example the counter is decremented only if it is not 0

```ts
type State = { count: number };

export class CounterService extends Service<State> {
  state: State = { count: 0 };

  async decrement() {
    if (this.state.count === 0) {
      return;
    }
    this.state.count--;
  }
}
```

## Access to the other services

For exemple we have a todoList form, it should append the form values to a todoList,
then the form resets.

The `submit` method of `TodoFormService` calls the method `append` of `TodoListService`

```ts
type Form = { name: string };

type TodoFormState = Form;
export class TodoFormService extends Service<TodoFormState> {
  state: TodoFormState = { name: "" };

  submit() {
    // highlight-next-line
    const todoListService = this.getService("todoList");
    // highlight-next-line
    todoListService.append(this.state);

    this.state.name = "";
  }
}
```

This way each service can have a single responsibility

## init()

You can write an init method that will be executed right after the core is instantiated
It is the perfect place to initialize listeners or setup dependencies

```ts
type State = { messages: string[] };

export class MessageService extends Service<State> {
  state: State = { messages: [] };

  init() {
    this.dependencies.notifications.onReceive(this.onReceive);
  }

  onReceive = (receivedNotification: string) => {
    this.state.messages.push(receivedNotification);
  }
}
```

## The dependencies

If your app is in clean architecture and uses the port-adapter pattern, you can access any of the dependencies in any service method

```ts
interface ShoesApiGateway {
  get(): Promise<Shoe[]>;
}

type Dependencies = {
  shoesApi: ShoesApiGateway;
};
```

```ts
type State = Shoe[];

export class ShoesService extends Service<State> {
  state: State = [];

  async loadShoes() {
    // highlight-next-line
    const shoes = await this.dependencies.shoesApi.get();
    this.state.push(...shoes);
  }
}
```

The dependencies can then be injected when creating the core

```ts
class RealShoesApiAdapter implements ShoesApiGateway {
  async get() {
    return axios.get<Shoe[]>("https://my-api/shoes/get");
  }
}

const core = createCore({ shoesApi: new RealShoesApiAdapter() });
```
