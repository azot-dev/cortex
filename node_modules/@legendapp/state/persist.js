'use strict';

var state = require('@legendapp/state');

const observablePersistConfiguration = {};
function configureObservablePersistence(options) {
    Object.assign(observablePersistConfiguration, options);
}

let validateMap;
function transformPath(path, pathTypes, map) {
    const data = {};
    let d = data;
    for (let i = 0; i < path.length; i++) {
        d = d[path[i]] = i === path.length - 1 ? null : pathTypes[i] === 'array' ? [] : {};
    }
    let value = transformObject(data, map);
    const pathOut = [];
    for (let i = 0; i < path.length; i++) {
        const key = Object.keys(value)[0];
        pathOut.push(key);
        value = value[key];
    }
    return pathOut;
}
function transformObject(dataIn, map) {
    if (process.env.NODE_ENV === 'development') {
        validateMap(map);
    }
    let ret = dataIn;
    if (dataIn) {
        if (dataIn === state.symbolDelete)
            return dataIn;
        if (state.isString(dataIn)) {
            return map[dataIn];
        }
        ret = {};
        const dict = Object.keys(map).length === 1 && map['_dict'];
        for (const key in dataIn) {
            let v = dataIn[key];
            if (dict) {
                ret[key] = transformObject(v, dict);
            }
            else {
                const mapped = map[key];
                if (mapped === undefined) {
                    // Don't transform dateModified if user doesn't want it
                    if (key !== '@') {
                        ret[key] = v;
                        if (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') {
                            console.error('A fatal field transformation error has occurred', key, dataIn, map);
                        }
                    }
                }
                else if (mapped !== null) {
                    if (v !== undefined && v !== null) {
                        if (map[key + '_val']) {
                            const mapChild = map[key + '_val'];
                            if (state.isArray(v)) {
                                v = v.map((vChild) => mapChild[vChild]);
                            }
                            else {
                                v = mapChild[v];
                            }
                        }
                        else if (map[key + '_arr'] && state.isArray(v)) {
                            const mapChild = map[key + '_arr'];
                            v = v.map((vChild) => transformObject(vChild, mapChild));
                        }
                        else if (state.isObject(v)) {
                            if (map[key + '_obj']) {
                                v = transformObject(v, map[key + '_obj']);
                            }
                            else if (map[key + '_dict']) {
                                const mapChild = map[key + '_dict'];
                                const out = {};
                                for (const keyChild in v) {
                                    out[keyChild] = transformObject(v[keyChild], mapChild);
                                }
                                v = out;
                            }
                        }
                    }
                    ret[mapped] = v;
                }
            }
        }
    }
    return ret;
}
function transformObjectWithPath(obj, path, pathTypes, fieldTransforms) {
    const constructed = state.constructObjectWithPath(path, obj, pathTypes);
    const transformed = transformObject(constructed, fieldTransforms);
    const transformedPath = transformPath(path, pathTypes, fieldTransforms);
    return { path: transformedPath, obj: state.deconstructObjectWithPath(transformedPath, transformed) };
}
const invertedMaps = new WeakMap();
function invertFieldMap(obj) {
    const existing = invertedMaps.get(obj);
    if (existing)
        return existing;
    const target = {};
    for (const key in obj) {
        const val = obj[key];
        if (key === '_dict') {
            target[key] = invertFieldMap(val);
        }
        else if (key.endsWith('_obj') || key.endsWith('_dict') || key.endsWith('_arr') || key.endsWith('_val')) {
            const keyMapped = obj[key.replace(/_obj|_dict|_arr|_val$/, '')];
            const suffix = key.match(/_obj|_dict|_arr|_val$/)[0];
            target[keyMapped + suffix] = invertFieldMap(val);
        }
        else if (typeof val === 'string') {
            target[val] = key;
        }
    }
    invertedMaps.set(obj, target);
    return target;
}
if (process.env.NODE_ENV === 'development') {
    validateMap = function (record) {
        const values = Object.values(record).filter((value) => {
            if (state.isObject(value)) {
                validateMap(value);
            }
            else {
                return state.isString(value);
            }
        });
        const uniques = Array.from(new Set(values));
        if (values.length !== uniques.length) {
            console.error('Field transform map has duplicate values', record, values.length, uniques.length);
        }
        return record;
    };
}

const mapPersistences = new WeakMap();
const persistState = state.observable({ inRemoteSync: false });
const metadatas = new WeakMap();
const promisesLocalSaves = new Set();
function parseLocalConfig(config) {
    return state.isString(config) ? { table: config, config: { name: config } } : { table: config.name, config };
}
function doInOrder(arg1, arg2) {
    return state.isPromise(arg1) ? arg1.then(arg2) : arg2(arg1);
}
function adjustSaveData(value, path, pathTypes, { adjustData, fieldTransforms, }) {
    if (fieldTransforms || (adjustData === null || adjustData === void 0 ? void 0 : adjustData.save)) {
        const transform = () => {
            if (fieldTransforms) {
                const { obj, path: pathTransformed } = transformObjectWithPath(value, path, pathTypes, fieldTransforms);
                value = obj;
                path = pathTransformed;
            }
            return { value, path };
        };
        if (adjustData === null || adjustData === void 0 ? void 0 : adjustData.save) {
            const constructed = state.constructObjectWithPath(path, value, pathTypes);
            const saved = adjustData.save(constructed);
            const deconstruct = (toDeconstruct) => {
                value = state.deconstructObjectWithPath(path, toDeconstruct);
                return transform();
            };
            return doInOrder(saved, deconstruct);
        }
        return transform();
    }
    return { value, path };
}
function adjustLoadData(value, { adjustData, fieldTransforms, }, doUserAdjustData) {
    if (fieldTransforms) {
        const inverted = invertFieldMap(fieldTransforms);
        value = transformObject(value, inverted);
    }
    if (doUserAdjustData && (adjustData === null || adjustData === void 0 ? void 0 : adjustData.load)) {
        value = adjustData.load(value);
    }
    return value;
}
async function updateMetadataImmediate(obs, localState, obsState, persistOptions, newMetadata) {
    const saves = Array.from(promisesLocalSaves);
    if (saves.length > 0) {
        await Promise.all(saves);
    }
    const { persistenceLocal } = localState;
    const local = persistOptions.local;
    const { table, config } = parseLocalConfig(local);
    // Save metadata
    const oldMetadata = metadatas.get(obs);
    const { modified, pending } = newMetadata;
    const needsUpdate = pending || (modified && (!oldMetadata || modified !== oldMetadata.modified));
    if (needsUpdate) {
        const metadata = Object.assign({}, oldMetadata, newMetadata);
        metadatas.set(obs, metadata);
        await persistenceLocal.updateMetadata(table, metadata, config);
        if (modified) {
            obsState.dateModified.set(modified);
        }
    }
}
function updateMetadata(obs, localState, obsState, persistOptions, newMetadata) {
    if (localState.timeoutSaveMetadata) {
        clearTimeout(localState.timeoutSaveMetadata);
    }
    localState.timeoutSaveMetadata = setTimeout(() => updateMetadataImmediate(obs, localState, obsState, persistOptions, newMetadata), 30);
}
let _queuedChanges = [];
async function processQueuedChanges() {
    // Get a local copy of the queued changes and clear the global queue
    const queuedChanges = _queuedChanges;
    _queuedChanges = [];
    // Note: Summary of the order of operations these functions:
    // 1. Prepare all changes for saving. This may involve waiting for promises if the user has asynchronous adjustData.
    // We need to prepare all of the changes in the queue before saving so that the saves happen in the correct order,
    // since some may take longer to adjustSaveData than others.
    const changes = await Promise.all(queuedChanges.map(prepChange));
    // 2. Save pending to the metadata table first. If this is the only operation that succeeds, it would try to save
    // the current value again on next load, which isn't too bad.
    // 3. Save local changes to storage. If they never make it to remote, then on the next load they will be pending
    // and attempted again.
    // 4. Wait for remote load or error if allowed
    // 5. Save to remote
    // 6. On successful save, merge changes (if any) back into observable
    // 7. Lastly, update metadata to clear pending and update dateModified. Doing this earlier could potentially cause
    // sync inconsistences so it's very important that this is last.
    changes.forEach(doChange);
}
async function prepChange(queuedChange) {
    const { obsState, changes, localState, persistOptions, inRemoteChange, isApplyingPending } = queuedChange;
    const local = persistOptions.local;
    const { config: configLocal } = parseLocalConfig(local);
    const configRemote = persistOptions.remote;
    const saveLocal = local && !configLocal.readonly && !isApplyingPending && obsState.isEnabledLocal.peek();
    const saveRemote = !inRemoteChange && configRemote && !configRemote.readonly && obsState.isEnabledRemote.peek();
    if (saveLocal || saveRemote) {
        if (saveLocal && !obsState.isLoadedLocal.peek()) {
            console.error('[legend-state] WARNING: An observable was changed before being loaded from persistence', local);
            return;
        }
        const changesLocal = [];
        const changesRemote = [];
        const changesPaths = new Set();
        let promisesAdjustData = [];
        // Reverse order
        for (let i = changes.length - 1; i >= 0; i--) {
            const { path } = changes[i];
            let found = false;
            // Optimization to only save the latest update at each path. We might have multiple changes at the same path
            // and we only need the latest value, so it starts from the end of the array, skipping any earlier changes
            // already processed. If a later change modifies a parent of an earlier change (which happens on delete()
            // it should be ignored as it's superseded by the parent modification.
            if (changesPaths.size > 0) {
                for (let u = 0; u < path.length; u++) {
                    if (changesPaths.has((u === path.length - 1 ? path : path.slice(0, u + 1)).join('/'))) {
                        found = true;
                        break;
                    }
                }
            }
            if (!found) {
                const pathStr = path.join('/');
                changesPaths.add(pathStr);
                const { prevAtPath, valueAtPath, pathTypes } = changes[i];
                if (saveLocal) {
                    const promiseAdjustLocal = adjustSaveData(valueAtPath, path, pathTypes, configLocal);
                    promisesAdjustData.push(doInOrder(promiseAdjustLocal, ({ path: pathAdjusted, value: valueAdjusted }) => {
                        // If path includes undefined there was a null in fieldTransforms so don't need to save it
                        if (!pathAdjusted.includes(undefined)) {
                            // Prepare the local change with the adjusted path/value
                            changesLocal.push({
                                path: pathAdjusted,
                                pathTypes,
                                prevAtPath,
                                valueAtPath: valueAdjusted,
                                pathStr,
                            });
                        }
                    }));
                }
                if (saveRemote) {
                    const promiseAdjustRemote = adjustSaveData(valueAtPath, path, pathTypes, configRemote);
                    promisesAdjustData.push(doInOrder(promiseAdjustRemote, ({ path: pathAdjusted, value: valueAdjusted }) => {
                        // If path includes undefined there was a null in fieldTransforms so don't need to save it
                        if (!pathAdjusted.includes(undefined)) {
                            // Prepare pending changes
                            if (!localState.pendingChanges) {
                                localState.pendingChanges = {};
                            }
                            // The "p" saved in pending should be the previous state before changes,
                            // so don't overwrite it if it already exists
                            if (!localState.pendingChanges[pathStr]) {
                                localState.pendingChanges[pathStr] = { p: prevAtPath !== null && prevAtPath !== void 0 ? prevAtPath : null, t: pathTypes };
                            }
                            // Pending value is the unadjusted value because it gets loaded without adjustment
                            // and forwarded through to onObsChange where it gets adjusted before save
                            localState.pendingChanges[pathStr].v = valueAtPath;
                            // Prepare the remote change with the adjusted path/value
                            changesRemote.push({
                                path: pathAdjusted,
                                pathTypes,
                                prevAtPath,
                                valueAtPath: valueAdjusted,
                                pathStr,
                            });
                        }
                    }));
                }
            }
        }
        // If there's any adjustData promises, wait for them before saving
        promisesAdjustData = promisesAdjustData.filter(Boolean);
        if (promisesAdjustData.length > 0) {
            await Promise.all(promisesAdjustData);
        }
        return { queuedChange, changesLocal, changesRemote };
    }
}
async function doChange(changeInfo) {
    var _a, _b;
    if (!changeInfo)
        return;
    const { queuedChange, changesLocal, changesRemote } = changeInfo;
    const { obs, obsState, localState, persistOptions } = queuedChange;
    const { persistenceLocal, persistenceRemote } = localState;
    const local = persistOptions.local;
    const { table, config: configLocal } = parseLocalConfig(local);
    const configRemote = persistOptions.remote;
    if (changesRemote.length > 0) {
        // First save pending changes before saving local or remote
        await updateMetadataImmediate(obs, localState, obsState, persistOptions, {
            pending: localState.pendingChanges,
        });
    }
    if (changesLocal.length > 0) {
        // Save the changes to local persistence before saving to remote. They are already marked as pending so
        // if remote sync fails or the app is closed before remote sync, it will attempt to sync them on the next load.
        let promiseSet = persistenceLocal.set(table, changesLocal, configLocal);
        if (promiseSet) {
            promiseSet = promiseSet.then(() => {
                promisesLocalSaves.delete(promiseSet);
            });
            // Keep track of local save promises so that updateMetadata runs only after everything is saved
            promisesLocalSaves.add(promiseSet);
            // await the local save before proceeding to save remotely
            await promiseSet;
        }
    }
    if (changesRemote.length > 0) {
        // Wait for remote to be ready before saving
        await state.when(() => obsState.isLoadedRemote.get() || (configRemote.allowSaveIfError && obsState.remoteError.get()));
        const saves = await Promise.all(changesRemote.map(async (change) => {
            const { path, valueAtPath, prevAtPath, pathTypes, pathStr } = change;
            // Save to remote persistence
            return persistenceRemote
                .save({
                obs,
                state: obsState,
                options: persistOptions,
                path: path,
                pathTypes,
                valueAtPath,
                prevAtPath,
            })
                .then(({ changes, dateModified }) => ({ changes, dateModified, pathStr }));
        }));
        // If this remote save changed anything then update persistence and metadata
        // Because save happens after a timeout and they're batched together, some calls to save will
        // return saved data and others won't, so those can be ignored.
        if (saves.filter(Boolean).length > 0) {
            if (local) {
                const metadata = {};
                const pending = (_a = persistenceLocal.getMetadata(table, configLocal)) === null || _a === void 0 ? void 0 : _a.pending;
                let adjustedChanges = [];
                for (let i = 0; i < saves.length; i++) {
                    const save = saves[i];
                    if (save) {
                        const { changes, dateModified, pathStr } = save;
                        // Clear pending for this path
                        if (pending === null || pending === void 0 ? void 0 : pending[pathStr]) {
                            // Remove pending from the saved object
                            delete pending[pathStr];
                            // Remove pending from local state
                            delete localState.pendingChanges[pathStr];
                            metadata.pending = pending;
                        }
                        if (dateModified) {
                            metadata.modified = dateModified;
                        }
                        // Remote can optionally have data that needs to be merged back into the observable,
                        // for example Firebase may update dateModified with the server timestamp
                        if (changes && !state.isEmpty(changes)) {
                            adjustedChanges.push(adjustLoadData(changes, persistOptions.remote, false));
                        }
                    }
                }
                if (adjustedChanges.length > 0) {
                    if (adjustedChanges.some((change) => state.isPromise(change))) {
                        adjustedChanges = await Promise.all(adjustedChanges);
                    }
                    onChangeRemote(() => state.mergeIntoObservable(obs, ...adjustedChanges));
                }
                if (local && !state.isEmpty(metadata)) {
                    updateMetadata(obs, localState, obsState, persistOptions, metadata);
                }
            }
            (_b = localState.onSaveRemote) === null || _b === void 0 ? void 0 : _b.call(localState);
        }
    }
}
function onObsChange(obs, obsState, localState, persistOptions, { changes }) {
    if (!state.internal.globalState.isLoadingLocal) {
        const inRemoteChange = state.internal.globalState.isLoadingRemote;
        const isApplyingPending = localState.isApplyingPending;
        // Queue changes in a microtask so that multiple changes within a frame get run together
        _queuedChanges.push({
            obs: obs,
            obsState,
            localState,
            persistOptions,
            changes,
            inRemoteChange,
            isApplyingPending: isApplyingPending,
        });
        if (_queuedChanges.length === 1) {
            queueMicrotask(processQueuedChanges);
        }
    }
}
function onChangeRemote(cb) {
    state.when(() => !persistState.inRemoteSync.get(), () => {
        // Remote changes should only update local state
        persistState.inRemoteSync.set(true);
        state.internal.globalState.isLoadingRemote = true;
        state.batch(cb, () => {
            state.internal.globalState.isLoadingRemote = false;
            persistState.inRemoteSync.set(false);
        });
    });
}
async function loadLocal(obs, persistOptions, obsState, localState) {
    var _a, _b;
    const { local } = persistOptions;
    const localPersistence = persistOptions.persistLocal || observablePersistConfiguration.persistLocal;
    if (local) {
        const { table, config } = parseLocalConfig(local);
        if (!localPersistence) {
            throw new Error('Local persistence is not configured');
        }
        // Ensure there's only one instance of the persistence plugin
        if (!mapPersistences.has(localPersistence)) {
            const persistenceLocal = new localPersistence();
            const mapValue = { persist: persistenceLocal, initialized: state.observable(false) };
            mapPersistences.set(localPersistence, mapValue);
            if (persistenceLocal.initialize) {
                const initializePromise = (_a = persistenceLocal.initialize) === null || _a === void 0 ? void 0 : _a.call(persistenceLocal, observablePersistConfiguration.persistLocalOptions);
                if (state.isPromise(initializePromise)) {
                    await initializePromise;
                }
            }
            mapValue.initialized.set(true);
        }
        const { persist: persistenceLocal, initialized } = mapPersistences.get(localPersistence);
        localState.persistenceLocal = persistenceLocal;
        if (!initialized.get()) {
            await state.when(initialized);
        }
        // If persistence has an asynchronous load, wait for it
        if (persistenceLocal.loadTable) {
            const promise = persistenceLocal.loadTable(table, config);
            if (promise) {
                await promise;
            }
        }
        // Get the value from state
        let value = persistenceLocal.getTable(table, config);
        const metadata = persistenceLocal.getMetadata(table, config);
        if (metadata) {
            metadatas.set(obs, metadata);
            localState.pendingChanges = metadata.pending;
            obsState.dateModified.set(metadata.modified);
        }
        // Merge the data from local persistence into the default state
        if (value !== null && value !== undefined) {
            // eslint-disable-next-line prefer-const
            let { adjustData, fieldTransforms } = config;
            if (fieldTransforms) {
                const valueLoaded = (_b = persistenceLocal.getTableTransformed) === null || _b === void 0 ? void 0 : _b.call(persistenceLocal, table, config);
                if (valueLoaded) {
                    value = valueLoaded;
                    fieldTransforms = undefined;
                }
            }
            value = adjustLoadData(value, { adjustData, fieldTransforms }, true);
            if (state.isPromise(value)) {
                value = await value;
            }
            state.batch(() => {
                // isLoadingLocal prevents saving remotely when two different persistences
                // are set on the same observable
                state.internal.globalState.isLoadingLocal = true;
                // We want to merge the local data on top of any initial state the object is created with
                state.mergeIntoObservable(obs, value);
            }, () => {
                state.internal.globalState.isLoadingLocal = false;
            });
        }
        obsState.peek().clearLocal = () => Promise.all([
            persistenceLocal.deleteTable(table, config),
            persistenceLocal.deleteMetadata(table, config),
        ]);
    }
    obsState.isLoadedLocal.set(true);
}
function persistObservable(obs, persistOptions) {
    const { remote, local } = persistOptions;
    const remotePersistence = persistOptions.persistRemote || (observablePersistConfiguration === null || observablePersistConfiguration === void 0 ? void 0 : observablePersistConfiguration.persistRemote);
    const localState = {};
    const obsState = state.observable({
        isLoadedLocal: false,
        isLoadedRemote: false,
        isEnabledLocal: true,
        isEnabledRemote: true,
        clearLocal: undefined,
        sync: () => Promise.resolve(),
        getPendingChanges: () => localState.pendingChanges,
    });
    if (local) {
        loadLocal(obs, persistOptions, obsState, localState);
    }
    if (remote) {
        if (!remotePersistence) {
            throw new Error('Remote persistence is not configured');
        }
        // Ensure there's only one instance of the persistence plugin
        if (!mapPersistences.has(remotePersistence)) {
            mapPersistences.set(remotePersistence, { persist: new remotePersistence() });
        }
        localState.persistenceRemote = mapPersistences.get(remotePersistence).persist;
        let isSynced = false;
        const sync = async () => {
            var _a, _b;
            if (!isSynced) {
                isSynced = true;
                localState.onSaveRemote = (_a = persistOptions.remote) === null || _a === void 0 ? void 0 : _a.onSaveRemote;
                const dateModified = (_b = metadatas.get(obs)) === null || _b === void 0 ? void 0 : _b.modified;
                localState.persistenceRemote.listen({
                    state: obsState,
                    obs,
                    options: persistOptions,
                    dateModified,
                    onLoad: () => {
                        obsState.isLoadedRemote.set(true);
                    },
                    onChange: async ({ value, path, pathTypes, mode, dateModified }) => {
                        // Note: value is the constructed value, path is used for setInObservableAtPath
                        // to start the set into the observable from the path
                        if (value !== undefined) {
                            value = adjustLoadData(value, remote, true);
                            if (state.isPromise(value)) {
                                value = await value;
                            }
                            const invertedMap = remote.fieldTransforms && invertFieldMap(remote.fieldTransforms);
                            if (path.length && invertedMap) {
                                path = transformPath(path, pathTypes, invertedMap);
                            }
                            if (mode === 'dateModified') {
                                if (dateModified && !state.isEmpty(value)) {
                                    onChangeRemote(() => {
                                        state.setInObservableAtPath(obs, path, value, 'assign');
                                    });
                                }
                            }
                            else {
                                const pending = localState.pendingChanges;
                                if (pending) {
                                    Object.keys(pending).forEach((key) => {
                                        const p = key.split('/').filter((p) => p !== '');
                                        const { v, t } = pending[key];
                                        value = state.setAtPath(value, p, t, v, obs.peek(), (path, value) => {
                                            delete pending[key];
                                            pending[path.join('/')] = {
                                                p: null,
                                                v: value,
                                                t: t.slice(0, path.length),
                                            };
                                        });
                                    });
                                }
                                onChangeRemote(() => {
                                    state.setInObservableAtPath(obs, path, value, mode);
                                });
                            }
                        }
                        if (dateModified && local) {
                            updateMetadata(obs, localState, obsState, persistOptions, {
                                modified: dateModified,
                            });
                        }
                    },
                });
                // Wait for remote to be ready before saving pending
                await state.when(() => obsState.isLoadedRemote.get() || (remote.allowSaveIfError && obsState.remoteError.get()));
                const pending = localState.pendingChanges;
                if (pending && !state.isEmpty(pending)) {
                    localState.isApplyingPending = true;
                    const keys = Object.keys(pending);
                    // Bundle up all the changes from pending
                    const changes = [];
                    for (let i = 0; i < keys.length; i++) {
                        const key = keys[i];
                        const path = key.split('/').filter((p) => p !== '');
                        const { p, v, t } = pending[key];
                        changes.push({ path, valueAtPath: v, prevAtPath: p, pathTypes: t });
                    }
                    // Send the changes into onObsChange so that they get persisted remotely
                    onObsChange(obs, obsState, localState, persistOptions, {
                        value: obs.peek(),
                        // TODO getPrevious if any remote persistence layers need it
                        getPrevious: () => undefined,
                        changes,
                    });
                    localState.isApplyingPending = false;
                }
            }
        };
        if (remote.manual) {
            obsState.assign({ sync });
        }
        else {
            state.when(() => !local || obsState.isLoadedLocal.get(), sync);
        }
    }
    state.when(obsState.isLoadedLocal, function () {
        obs.onChange(onObsChange.bind(this, obs, obsState, localState, persistOptions));
    });
    return obsState;
}

function isInRemoteChange() {
    return state.internal.globalState.isLoadingRemote;
}
const internal = {
    observablePersistConfiguration,
};

exports.configureObservablePersistence = configureObservablePersistence;
exports.internal = internal;
exports.invertFieldMap = invertFieldMap;
exports.isInRemoteChange = isInRemoteChange;
exports.mapPersistences = mapPersistences;
exports.onChangeRemote = onChangeRemote;
exports.persistObservable = persistObservable;
exports.persistState = persistState;
exports.transformObject = transformObject;
exports.transformPath = transformPath;
//# sourceMappingURL=persist.js.map
