1. Tests React
2. Tests Typescript React
3. Tests Typescript core

4. Ecriture des hooks avec des states observables, donc legendapp (pas de useState)
5. Utiliser une factory pour générer tous les hooks
6. Update de la documentation

- deplacement des frameworks dans un dossier frameworks
- detection et déploiement automatique des changements de frameworks dans la ci (pas prio avant que yoyo travaille dessus)

7. Système de persistence

- système de déploiement automatique d'adapteurs
- autogénération des README.md automatique des adapteurs dans le readme.md
- ajout automatique des nouveaux adapteurs dans la partie docusaurus
- docusaurus needs déploiement d'adapteurs dans la CI
- adapteurs: react-native => ReactNative
- check du workflow complet

- workflow de pull requests

- créer ces hooks:

const todoService = useServices('todo')
useMethod => const { isLoading, isError, isSuccess, isIdle, callback, data } = useMethod(() => todoService.append('salut')) // charge manuellement
useMethodMount => const { isLoading, isError, isSuccess, isIdle, recall, data } = useMethod(() => todoService.append('salut')) // charge au premier render
on part sur ça
Dire dans la doc que je ne préfère pas utiliser data, et garder ça pour les view models

créer un hook factory, qui renvoie toute la lib de hooks, comme ça on appelle une seule factory

- suppression du dossier lib et de l'exemple pour tout faire remonter d'un niveau

- correction warning invalid script quand on installe les package.json

- créer un exemple de todo list pour montrer l'interaction entre les services
- créer un exemple d'authentification pour montrer le principe de port/adapters
- ajouter une FAQ pour expliquer si c'est utilisable avec GraphQL